/**
 * Client-side AI helper for video editing
 * This file provides client-side mock implementations that would normally be generated by wasp
 */

import { Project } from './components/types';
import { ensureCompositionIDs } from './atoms';

// Type definitions
interface VideoAIPromptInput {
  projectId: string;
  prompt: string;
  projectData: Project;
}

interface VideoAIResponse {
  message: string;
  updatedProject?: Partial<Project>;
  changes?: Array<{
    type: 'add' | 'modify' | 'delete';
    elementType: string;
    elementId: string;
    description: string;
  }>;
}

/**
 * Mock client implementation of processVideoAIPrompt
 * In a real app, this would be a client function generated by wasp that calls the server
 * @param input Request input with project ID, prompt text, and project data
 * @returns Promise with AI processing results
 */
export async function processVideoAIPrompt(
  input: VideoAIPromptInput
): Promise<VideoAIResponse> {
  const { projectId, prompt, projectData } = input;
  
  try {
    // In a real implementation, this would call the server operation via HTTP
    // For now, we'll simulate the AI by making simple project changes based on the prompt
    console.log('Processing AI prompt (client mock):', prompt);
    
    // Very simple AI simulation that looks for keywords in the prompt
    const updatedProject = simulateAI(prompt, projectData);
    
    // Return a mock response
    return {
      message: `I've processed your request: "${prompt}" and made some changes to your project.`,
      updatedProject,
      changes: [
        {
          type: 'modify',
          elementType: 'text',
          elementId: 'simulated',
          description: 'Updated based on your request'
        }
      ]
    };
  } catch (error) {
    console.error('Error in client processVideoAIPrompt:', error);
    throw new Error('Failed to process video AI prompt');
  }
}

/**
 * Extremely simple AI simulation that modifies the project based on keywords in the prompt
 * @param prompt The user's prompt text
 * @param projectData The current project data
 * @returns Modified project data
 */
function simulateAI(prompt: string, projectData: Project): Partial<Project> {
  // Deep clone the project to avoid modifying the original
  const project = JSON.parse(JSON.stringify(projectData)) as Project;
  
  // Ensure all pages and elements have IDs after cloning
  if (project.composition) {
    project.composition = ensureCompositionIDs(project.composition);
  }
  
  const lowerPrompt = prompt.toLowerCase();
  
  // Look for specific keywords and make simple changes
  
  // Add a text element if requested
  if (lowerPrompt.includes('add text') || lowerPrompt.includes('text overlay')) {
    const page = project.composition.pages[0];
    if (page) {
      const textElement = {
        id: `text_${Date.now()}`,
        type: 'text' as const,
        left: 100,
        top: 100,
        width: 400,
        height: 100,
        text: 'New Text Element',
        fontSize: 32,
        color: '#ffffff',
        fontWeight: 'bold',
        textAlign: 'center' as const,
        opacity: 1,
        zIndex: 10,
        rotation: 0
      };
      
      page.elements.push(textElement);
    }
  }
  
  // Modify colors if requested
  if (lowerPrompt.includes('change color') || lowerPrompt.includes('color correction')) {
    project.composition.pages.forEach(page => {
      page.elements.forEach(element => {
        if (element.type === 'text' && element.color) {
          // Change text colors to something vibrant
          element.color = '#00e676';
        }
      });
      
      // Change background color
      if (page.backgroundColor) {
        page.backgroundColor = '#0a1929';
      }
    });
  }
  
  // Create a transition if requested
  if (lowerPrompt.includes('transition') || lowerPrompt.includes('animate')) {
    project.composition.pages.forEach(page => {
      page.elements.forEach(element => {
        // Add animation properties
        if (!element.startTime) element.startTime = 0;
        if (!element.endTime) element.endTime = 5;
      });
    });
  }
  
  return project;
}
